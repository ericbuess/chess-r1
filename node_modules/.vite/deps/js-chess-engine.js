var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/js-chess-engine/dist/js-chess-engine.js
var require_js_chess_engine = __commonJS({
  "node_modules/js-chess-engine/dist/js-chess-engine.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("js-chess-engine", [], e) : "object" == typeof exports ? exports["js-chess-engine"] = e() : t["js-chess-engine"] = e();
    }(exports, function() {
      return function(t) {
        var e = {};
        function i(n) {
          if (e[n]) return e[n].exports;
          var o = e[n] = { i: n, l: false, exports: {} };
          return t[n].call(o.exports, o, o.exports, i), o.l = true, o.exports;
        }
        return i.m = t, i.c = e, i.d = function(t2, e2, n) {
          i.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
        }, i.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, i.t = function(t2, e2) {
          if (1 & e2 && (t2 = i(t2)), 8 & e2) return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule) return t2;
          var n = /* @__PURE__ */ Object.create(null);
          if (i.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2) for (var o in t2) i.d(n, o, (function(e3) {
            return t2[e3];
          }).bind(null, o));
          return n;
        }, i.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return i.d(e2, "a", e2), e2;
        }, i.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, i.p = "", i(i.s = 0);
      }([function(t, e, i) {
        "use strict";
        i.r(e), i.d(e, "Game", function() {
          return $;
        }), i.d(e, "moves", function() {
          return J;
        }), i.d(e, "status", function() {
          return V;
        }), i.d(e, "getFen", function() {
          return Y;
        }), i.d(e, "move", function() {
          return z;
        }), i.d(e, "aiMove", function() {
          return X;
        });
        const n = ["A", "B", "C", "D", "E", "F", "G", "H"], o = ["1", "2", "3", "4", "5", "6", "7", "8"], s = { KING_W: "K", QUEEN_W: "Q", ROOK_W: "R", BISHOP_W: "B", KNIGHT_W: "N", PAWN_W: "P", KING_B: "k", QUEEN_B: "q", ROOK_B: "r", BISHOP_B: "b", KNIGHT_B: "n", PAWN_B: "p" }, r = "black", c = "white", l = [0, 1, 2, 3, 4], a = { 0: 1, 1: 2, 2: 2, 3: 3, 4: 3, 5: 4 }, u = { 0: 2, 1: 2, 2: 4, 3: 4, 4: 5, 5: 5 }, h = { fullMove: 1, halfMove: 0, enPassant: null, isFinished: false, checkMate: false, check: false, turn: c }, g = Object.assign({ pieces: { E1: "K", D1: "Q", A1: "R", H1: "R", C1: "B", F1: "B", B1: "N", G1: "N", A2: "P", B2: "P", C2: "P", D2: "P", E2: "P", F2: "P", G2: "P", H2: "P", E8: "k", D8: "q", A8: "r", H8: "r", C8: "b", F8: "b", B8: "n", G8: "n", A7: "p", B7: "p", C7: "p", D7: "p", E7: "p", F7: "p", G7: "p", H7: "p" }, castling: { whiteShort: true, blackShort: true, whiteLong: true, blackLong: true } }, h), f = { UP: { A1: "A2", A2: "A3", A3: "A4", A4: "A5", A5: "A6", A6: "A7", A7: "A8", A8: null, B1: "B2", B2: "B3", B3: "B4", B4: "B5", B5: "B6", B6: "B7", B7: "B8", B8: null, C1: "C2", C2: "C3", C3: "C4", C4: "C5", C5: "C6", C6: "C7", C7: "C8", C8: null, D1: "D2", D2: "D3", D3: "D4", D4: "D5", D5: "D6", D6: "D7", D7: "D8", D8: null, E1: "E2", E2: "E3", E3: "E4", E4: "E5", E5: "E6", E6: "E7", E7: "E8", E8: null, F1: "F2", F2: "F3", F3: "F4", F4: "F5", F5: "F6", F6: "F7", F7: "F8", F8: null, G1: "G2", G2: "G3", G3: "G4", G4: "G5", G5: "G6", G6: "G7", G7: "G8", G8: null, H1: "H2", H2: "H3", H3: "H4", H4: "H5", H5: "H6", H6: "H7", H7: "H8", H8: null }, DOWN: { A1: null, A2: "A1", A3: "A2", A4: "A3", A5: "A4", A6: "A5", A7: "A6", A8: "A7", B1: null, B2: "B1", B3: "B2", B4: "B3", B5: "B4", B6: "B5", B7: "B6", B8: "B7", C1: null, C2: "C1", C3: "C2", C4: "C3", C5: "C4", C6: "C5", C7: "C6", C8: "C7", D1: null, D2: "D1", D3: "D2", D4: "D3", D5: "D4", D6: "D5", D7: "D6", D8: "D7", E1: null, E2: "E1", E3: "E2", E4: "E3", E5: "E4", E6: "E5", E7: "E6", E8: "E7", F1: null, F2: "F1", F3: "F2", F4: "F3", F5: "F4", F6: "F5", F7: "F6", F8: "F7", G1: null, G2: "G1", G3: "G2", G4: "G3", G5: "G4", G6: "G5", G7: "G6", G8: "G7", H1: null, H2: "H1", H3: "H2", H4: "H3", H5: "H4", H6: "H5", H7: "H6", H8: "H7" }, LEFT: { A1: null, A2: null, A3: null, A4: null, A5: null, A6: null, A7: null, A8: null, B1: "A1", B2: "A2", B3: "A3", B4: "A4", B5: "A5", B6: "A6", B7: "A7", B8: "A8", C1: "B1", C2: "B2", C3: "B3", C4: "B4", C5: "B5", C6: "B6", C7: "B7", C8: "B8", D1: "C1", D2: "C2", D3: "C3", D4: "C4", D5: "C5", D6: "C6", D7: "C7", D8: "C8", E1: "D1", E2: "D2", E3: "D3", E4: "D4", E5: "D5", E6: "D6", E7: "D7", E8: "D8", F1: "E1", F2: "E2", F3: "E3", F4: "E4", F5: "E5", F6: "E6", F7: "E7", F8: "E8", G1: "F1", G2: "F2", G3: "F3", G4: "F4", G5: "F5", G6: "F6", G7: "F7", G8: "F8", H1: "G1", H2: "G2", H3: "G3", H4: "G4", H5: "G5", H6: "G6", H7: "G7", H8: "G8" }, RIGHT: { A1: "B1", A2: "B2", A3: "B3", A4: "B4", A5: "B5", A6: "B6", A7: "B7", A8: "B8", B1: "C1", B2: "C2", B3: "C3", B4: "C4", B5: "C5", B6: "C6", B7: "C7", B8: "C8", C1: "D1", C2: "D2", C3: "D3", C4: "D4", C5: "D5", C6: "D6", C7: "D7", C8: "D8", D1: "E1", D2: "E2", D3: "E3", D4: "E4", D5: "E5", D6: "E6", D7: "E7", D8: "E8", E1: "F1", E2: "F2", E3: "F3", E4: "F4", E5: "F5", E6: "F6", E7: "F7", E8: "F8", F1: "G1", F2: "G2", F3: "G3", F4: "G4", F5: "G5", F6: "G6", F7: "G7", F8: "G8", G1: "H1", G2: "H2", G3: "H3", G4: "H4", G5: "H5", G6: "H6", G7: "H7", G8: "H8", H1: null, H2: null, H3: null, H4: null, H5: null, H6: null, H7: null, H8: null }, UP_LEFT: { A1: null, A2: null, A3: null, A4: null, A5: null, A6: null, A7: null, A8: null, B1: "A2", B2: "A3", B3: "A4", B4: "A5", B5: "A6", B6: "A7", B7: "A8", B8: null, C1: "B2", C2: "B3", C3: "B4", C4: "B5", C5: "B6", C6: "B7", C7: "B8", C8: null, D1: "C2", D2: "C3", D3: "C4", D4: "C5", D5: "C6", D6: "C7", D7: "C8", D8: null, E1: "D2", E2: "D3", E3: "D4", E4: "D5", E5: "D6", E6: "D7", E7: "D8", E8: null, F1: "E2", F2: "E3", F3: "E4", F4: "E5", F5: "E6", F6: "E7", F7: "E8", F8: null, G1: "F2", G2: "F3", G3: "F4", G4: "F5", G5: "F6", G6: "F7", G7: "F8", G8: null, H1: "G2", H2: "G3", H3: "G4", H4: "G5", H5: "G6", H6: "G7", H7: "G8", H8: null }, DOWN_RIGHT: { A1: null, A2: "B1", A3: "B2", A4: "B3", A5: "B4", A6: "B5", A7: "B6", A8: "B7", B1: null, B2: "C1", B3: "C2", B4: "C3", B5: "C4", B6: "C5", B7: "C6", B8: "C7", C1: null, C2: "D1", C3: "D2", C4: "D3", C5: "D4", C6: "D5", C7: "D6", C8: "D7", D1: null, D2: "E1", D3: "E2", D4: "E3", D5: "E4", D6: "E5", D7: "E6", D8: "E7", E1: null, E2: "F1", E3: "F2", E4: "F3", E5: "F4", E6: "F5", E7: "F6", E8: "F7", F1: null, F2: "G1", F3: "G2", F4: "G3", F5: "G4", F6: "G5", F7: "G6", F8: "G7", G1: null, G2: "H1", G3: "H2", G4: "H3", G5: "H4", G6: "H5", G7: "H6", G8: "H7", H1: null, H2: null, H3: null, H4: null, H5: null, H6: null, H7: null, H8: null }, UP_RIGHT: { A1: "B2", A2: "B3", A3: "B4", A4: "B5", A5: "B6", A6: "B7", A7: "B8", A8: null, B1: "C2", B2: "C3", B3: "C4", B4: "C5", B5: "C6", B6: "C7", B7: "C8", B8: null, C1: "D2", C2: "D3", C3: "D4", C4: "D5", C5: "D6", C6: "D7", C7: "D8", C8: null, D1: "E2", D2: "E3", D3: "E4", D4: "E5", D5: "E6", D6: "E7", D7: "E8", D8: null, E1: "F2", E2: "F3", E3: "F4", E4: "F5", E5: "F6", E6: "F7", E7: "F8", E8: null, F1: "G2", F2: "G3", F3: "G4", F4: "G5", F5: "G6", F6: "G7", F7: "G8", F8: null, G1: "H2", G2: "H3", G3: "H4", G4: "H5", G5: "H6", G6: "H7", G7: "H8", G8: null, H1: null, H2: null, H3: null, H4: null, H5: null, H6: null, H7: null, H8: null }, DOWN_LEFT: { A1: null, A2: null, A3: null, A4: null, A5: null, A6: null, A7: null, A8: null, B1: null, B2: "A1", B3: "A2", B4: "A3", B5: "A4", B6: "A5", B7: "A6", B8: "A7", C1: null, C2: "B1", C3: "B2", C4: "B3", C5: "B4", C6: "B5", C7: "B6", C8: "B7", D1: null, D2: "C1", D3: "C2", D4: "C3", D5: "C4", D6: "C5", D7: "C6", D8: "C7", E1: null, E2: "D1", E3: "D2", E4: "D3", E5: "D4", E6: "D5", E7: "D6", E8: "D7", F1: null, F2: "E1", F3: "E2", F4: "E3", F5: "E4", F6: "E5", F7: "E6", F8: "E7", G1: null, G2: "F1", G3: "F2", G4: "F3", G5: "F4", G6: "F5", G7: "F6", G8: "F7", H1: null, H2: "G1", H3: "G2", H4: "G3", H5: "G4", H6: "G5", H7: "G6", H8: "G7" } }, C = [[0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 2, 3, 3, 2, 1, 1], [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5], [0, 0, 0, 2, 2, 0, 0, 0], [0.5, 0, 1, 0, 0, 1, 0, 0.5], [0.5, 0, 0, -2, -2, 0, 0, 0.5], [0, 0, 0, 0, 0, 0, 0, 0]], P = [[-4, -3, -2, -2, -2, -2, -3, -4], [-3, -2, 0, 0, 0, 0, -2, -3], [-2, 0, 1, 1.5, 1.5, 1, 0, -2], [-2, 0.5, 1.5, 2, 2, 1.5, 0.5, -2], [-2, 0, 1.5, 2, 2, 1.5, 0, -2], [-2, 0.5, 1, 1.5, 1.5, 1, 0.5, -2], [-3, -2, 0, 0.5, 0.5, 0, -2, -3], [-4, -3, -2, -2, -2, -2, -3, -4]], p = [[-2, -1, -1, -1, -1, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 1, 1, 0.5, 0, -1], [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1], [-1, 0, 1, 1, 1, 1, 0, -1], [-1, 1, 1, 1, 1, 1, 1, -1], [-1, 0.5, 0, 0, 0, 0, 0.5, -1], [-2, -1, -1, -1, -1, -1, -1, -2]], E = [[0, 0, 0, 0, 0, 0, 0, 0], [0.5, 1, 1, 1, 1, 1, 1, 0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [0, 0, 0, 0.5, 0.5, 0, 0, 0]], B = [[-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-2, -3, -3, -4, -4, -3, -3, -2], [-1, -2, -2, -2, -2, -2, -2, -1], [2, 2, 0, 0, 0, 0, 2, 2], [2, 3, 1, 0, 0, 1, 3, 2]], F = [[-2, -1, -1, -0.5, -0.5, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1], [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1], [-1, 0, 0.5, 0, 0, 0, 0, -1], [-2, -1, -1, -0.5, -0.5, -1, -1, -2]], G = { P: C.slice().reverse(), p: C, N: P.slice().reverse(), n: P, B: p.slice().reverse(), b: p, R: E.slice().reverse(), r: E, K: B.slice().reverse(), k: B, Q: F.slice().reverse(), q: F };
        function D(t2) {
          return f.UP[t2];
        }
        function A(t2) {
          return f.DOWN[t2];
        }
        function H(t2) {
          return f.LEFT[t2];
        }
        function b(t2) {
          return f.RIGHT[t2];
        }
        function d(t2) {
          return f.UP_LEFT[t2];
        }
        function v(t2) {
          return f.UP_RIGHT[t2];
        }
        function k(t2) {
          return f.DOWN_LEFT[t2];
        }
        function y(t2) {
          return f.DOWN_RIGHT[t2];
        }
        function w(t2) {
          const e2 = d(t2);
          return e2 ? D(e2) : null;
        }
        function O(t2) {
          const e2 = d(t2);
          return e2 ? H(e2) : null;
        }
        function L(t2) {
          const e2 = v(t2);
          return e2 ? D(e2) : null;
        }
        function m(t2) {
          const e2 = v(t2);
          return e2 ? b(e2) : null;
        }
        function M(t2) {
          const e2 = k(t2);
          return e2 ? A(e2) : null;
        }
        function K(t2) {
          const e2 = k(t2);
          return e2 ? H(e2) : null;
        }
        function N(t2) {
          const e2 = y(t2);
          return e2 ? A(e2) : null;
        }
        function S(t2) {
          const e2 = y(t2);
          return e2 ? b(e2) : null;
        }
        function j(t2, e2) {
          return e2 === c ? f.UP[t2] : f.DOWN[t2];
        }
        function _(t2, e2) {
          return e2 === c ? f.UP_LEFT[t2] : f.DOWN_RIGHT[t2];
        }
        function W(t2, e2) {
          return e2 === c ? f.UP_RIGHT[t2] : f.DOWN_LEFT[t2];
        }
        function U(t2, e2) {
          return e2 === c ? f.DOWN_LEFT[t2] : f.UP_RIGHT[t2];
        }
        function R(t2, e2) {
          return e2 === c ? f.DOWN_RIGHT[t2] : f.UP_LEFT[t2];
        }
        function T(t2) {
          return { k: 10, q: 9, r: 5, b: 3, n: 3, p: 1 }[t2.toLowerCase()] || 0;
        }
        function I(t2) {
          return "string" == typeof t2 && t2.match("^[a-hA-H]{1}[1-8]{1}$");
        }
        const x = -1e3, Q = 1e3;
        class q {
          constructor(t2 = JSON.parse(JSON.stringify(g))) {
            if ("object" == typeof t2) this.configuration = Object.assign({}, h, t2);
            else {
              if ("string" != typeof t2) throw new Error(`Unknown configuration type ${typeof config}.`);
              this.configuration = Object.assign({}, h, function(t3 = "") {
                const [e2, i2, s2, l2, a2, u2] = t3.split(" "), h2 = { pieces: Object.fromEntries(e2.split("/").flatMap((t4, e3) => {
                  let i3 = 0;
                  return t4.split("").reduce((t5, s3) => {
                    const r2 = s3.match(/k|b|q|n|p|r/i);
                    r2 && (t5.push([`${n[i3]}${o[7 - e3]}`, r2[0]]), i3 += 1);
                    const c2 = s3.match(/[1-8]/);
                    return c2 && (i3 += Number(c2)), t5;
                  }, []);
                })) };
                return h2.turn = "b" === i2 ? r : c, h2.castling = { whiteLong: false, whiteShort: false, blackLong: false, blackShort: false }, s2.includes("K") && (h2.castling.whiteShort = true), s2.includes("k") && (h2.castling.blackShort = true), s2.includes("Q") && (h2.castling.whiteLong = true), s2.includes("q") && (h2.castling.blackLong = true), I(l2) && (h2.enPassant = l2.toUpperCase()), h2.halfMove = parseInt(a2), h2.fullMove = parseInt(u2), h2;
              }(t2));
            }
            this.configuration.castling || (this.configuration.castling = { whiteShort: true, blackShort: true, whiteLong: true, blackLong: true }), this.history = [];
          }
          getAttackingFields(t2 = this.getPlayingColor()) {
            let e2 = [];
            for (const i2 in this.configuration.pieces) {
              const n2 = this.getPiece(i2);
              this.getPieceColor(n2) === t2 && (e2 = [...e2, ...this.getPieceMoves(n2, i2)]);
            }
            return e2;
          }
          isAttackingKing(t2 = this.getPlayingColor()) {
            let e2 = null;
            for (const i2 in this.configuration.pieces) {
              const n2 = this.getPiece(i2);
              if (this.isKing(n2) && this.getPieceColor(n2) !== t2) {
                e2 = i2;
                break;
              }
            }
            return this.isPieceUnderAttack(e2);
          }
          isPieceUnderAttack(t2) {
            const e2 = this.getPieceOnLocationColor(t2), i2 = this.getEnemyColor(e2);
            let n2 = false, o2 = t2, s2 = 0;
            for (; D(o2) && !n2; ) {
              o2 = D(o2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isRook(t3) || this.isQueen(t3) || this.isKing(t3) && 1 === s2) && (n2 = true), t3) break;
            }
            for (o2 = t2, s2 = 0; A(o2) && !n2; ) {
              o2 = A(o2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isRook(t3) || this.isQueen(t3) || this.isKing(t3) && 1 === s2) && (n2 = true), t3) break;
            }
            for (o2 = t2, s2 = 0; H(o2) && !n2; ) {
              o2 = H(o2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isRook(t3) || this.isQueen(t3) || this.isKing(t3) && 1 === s2) && (n2 = true), t3) break;
            }
            for (o2 = t2, s2 = 0; b(o2) && !n2; ) {
              o2 = b(o2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isRook(t3) || this.isQueen(t3) || this.isKing(t3) && 1 === s2) && (n2 = true), t3) break;
            }
            for (o2 = t2, s2 = 0; W(o2, e2) && !n2; ) {
              o2 = W(o2, e2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isBishop(t3) || this.isQueen(t3) || 1 === s2 && (this.isKing(t3) || this.isPawn(t3))) && (n2 = true), t3) break;
            }
            for (o2 = t2, s2 = 0; _(o2, e2) && !n2; ) {
              o2 = _(o2, e2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isBishop(t3) || this.isQueen(t3) || 1 === s2 && (this.isKing(t3) || this.isPawn(t3))) && (n2 = true), t3) break;
            }
            for (o2 = t2, s2 = 0; R(o2, e2) && !n2; ) {
              o2 = R(o2, e2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isBishop(t3) || this.isQueen(t3) || this.isKing(t3) && 1 === s2) && (n2 = true), t3) break;
            }
            for (o2 = t2, s2 = 0; U(o2, e2) && !n2; ) {
              o2 = U(o2, e2), s2++;
              const t3 = this.getPiece(o2);
              if (t3 && this.getPieceColor(t3) === i2 && (this.isBishop(t3) || this.isQueen(t3) || this.isKing(t3) && 1 === s2) && (n2 = true), t3) break;
            }
            o2 = L(t2);
            let r2 = this.getPiece(o2);
            return r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), o2 = m(t2), r2 = this.getPiece(o2), r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), o2 = O(t2), r2 = this.getPiece(o2), r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), o2 = w(t2), r2 = this.getPiece(o2), r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), o2 = M(t2), r2 = this.getPiece(o2), r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), o2 = K(t2), r2 = this.getPiece(o2), r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), o2 = N(t2), r2 = this.getPiece(o2), r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), o2 = S(t2), r2 = this.getPiece(o2), r2 && this.getPieceColor(r2) === i2 && this.isKnight(r2) && (n2 = true), n2;
          }
          hasPlayingPlayerCheck() {
            return this.isAttackingKing(this.getNonPlayingColor());
          }
          hasNonPlayingPlayerCheck() {
            return this.isAttackingKing(this.getPlayingColor());
          }
          getLowestValuePieceAttackingLocation(t2, e2 = this.getPlayingColor()) {
            let i2 = null;
            for (const n2 in this.configuration.pieces) {
              const o2 = this.getPiece(n2);
              this.getPieceColor(o2) === e2 && this.getPieceMoves(o2, n2).map((e3) => {
                e3 === t2 && (null === i2 || T(o2) < i2) && (i2 = T(o2));
              });
            }
            return i2;
          }
          getMoves(t2 = this.getPlayingColor(), e2 = null) {
            const i2 = {};
            let n2 = 0;
            for (const e3 in this.configuration.pieces) {
              const o3 = this.getPiece(e3);
              if (this.getPieceColor(o3) === t2) {
                const t3 = this.getPieceMoves(o3, e3);
                t3.length && n2++, Object.assign(i2, { [e3]: t3 });
              }
            }
            const o2 = this.getAttackingFields(this.getNonPlayingColor());
            if (this.isLeftCastlingPossible(o2) && (this.isPlayingWhite() && i2.E1.push("C1"), this.isPlayingBlack() && i2.E8.push("C8")), this.isRightCastlingPossible(o2) && (this.isPlayingWhite() && i2.E1.push("G1"), this.isPlayingBlack() && i2.E8.push("G8")), e2 && n2 > e2) return i2;
            const s2 = {};
            for (const t3 in i2) i2[t3].map((e3) => {
              const i3 = { pieces: Object.assign({}, this.configuration.pieces), castling: Object.assign({}, this.configuration.castling) }, n3 = new q(i3);
              n3.move(t3, e3), (this.isPlayingWhite() && !n3.isAttackingKing(r) || this.isPlayingBlack() && !n3.isAttackingKing(c)) && (s2[t3] || (s2[t3] = []), s2[t3].push(e3));
            });
            return Object.keys(s2).length || (this.configuration.isFinished = true, this.hasPlayingPlayerCheck() && (this.configuration.checkMate = true)), s2;
          }
          isLeftCastlingPossible(t2) {
            if (this.isPlayingWhite() && !this.configuration.castling.whiteLong) return false;
            if (this.isPlayingBlack() && !this.configuration.castling.blackLong) return false;
            let e2 = null;
            if (this.isPlayingWhite() && "K" === this.getPiece("E1") && "R" === this.getPiece("A1") && !t2.includes("E1") ? e2 = "E1" : this.isPlayingBlack() && "k" === this.getPiece("E8") && "r" === this.getPiece("A8") && !t2.includes("E8") && (e2 = "E8"), !e2) return false;
            let i2 = H(e2);
            return !this.getPiece(i2) && !t2.includes(i2) && (i2 = H(i2), !this.getPiece(i2) && !t2.includes(i2) && (i2 = H(i2), !this.getPiece(i2)));
          }
          isRightCastlingPossible(t2) {
            if (this.isPlayingWhite() && !this.configuration.castling.whiteShort) return false;
            if (this.isPlayingBlack() && !this.configuration.castling.blackShort) return false;
            let e2 = null;
            if (this.isPlayingWhite() && "K" === this.getPiece("E1") && "R" === this.getPiece("H1") && !t2.includes("E1") ? e2 = "E1" : this.isPlayingBlack() && "k" === this.getPiece("E8") && "r" === this.getPiece("H8") && !t2.includes("E8") && (e2 = "E8"), !e2) return false;
            let i2 = b(e2);
            return !this.getPiece(i2) && !t2.includes(i2) && (i2 = b(i2), !this.getPiece(i2) && !t2.includes(i2));
          }
          getPieceMoves(t2, e2) {
            return this.isPawn(t2) ? this.getPawnMoves(t2, e2) : this.isKnight(t2) ? this.getKnightMoves(t2, e2) : this.isRook(t2) ? this.getRookMoves(t2, e2) : this.isBishop(t2) ? this.getBishopMoves(t2, e2) : this.isQueen(t2) ? this.getQueenMoves(t2, e2) : this.isKing(t2) ? this.getKingMoves(t2, e2) : [];
          }
          isPawn(t2) {
            return "P" === t2.toUpperCase();
          }
          isKnight(t2) {
            return "N" === t2.toUpperCase();
          }
          isRook(t2) {
            return "R" === t2.toUpperCase();
          }
          isBishop(t2) {
            return "B" === t2.toUpperCase();
          }
          isQueen(t2) {
            return "Q" === t2.toUpperCase();
          }
          isKing(t2) {
            return "K" === t2.toUpperCase();
          }
          getPawnMoves(t2, e2) {
            const i2 = [], n2 = this.getPieceColor(t2);
            let o2 = j(e2, n2);
            return o2 && !this.getPiece(o2) && (i2.push(o2), o2 = j(o2, n2), function(t3, e3) {
              if (t3 === c && "2" === e3[1]) return true;
              if (t3 === r && "7" === e3[1]) return true;
              return false;
            }(n2, e2) && o2 && !this.getPiece(o2) && i2.push(o2)), o2 = _(e2, n2), o2 && (this.getPiece(o2) && this.getPieceOnLocationColor(o2) !== n2 || o2 === this.configuration.enPassant) && i2.push(o2), o2 = W(e2, n2), o2 && (this.getPiece(o2) && this.getPieceOnLocationColor(o2) !== n2 || o2 === this.configuration.enPassant) && i2.push(o2), i2;
          }
          getKnightMoves(t2, e2) {
            const i2 = [], n2 = this.getPieceColor(t2);
            let o2 = L(e2);
            return o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = m(e2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = w(e2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = O(e2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = K(e2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = M(e2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = S(e2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = N(e2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), i2;
          }
          getRookMoves(t2, e2) {
            const i2 = [], n2 = this.getPieceColor(t2);
            let o2 = e2;
            for (; D(o2); ) {
              o2 = D(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            for (o2 = e2; A(o2); ) {
              o2 = A(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            for (o2 = e2; b(o2); ) {
              o2 = b(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            for (o2 = e2; H(o2); ) {
              o2 = H(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            return i2;
          }
          getBishopMoves(t2, e2) {
            const i2 = [], n2 = this.getPieceColor(t2);
            let o2 = e2;
            for (; d(o2); ) {
              o2 = d(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            for (o2 = e2; v(o2); ) {
              o2 = v(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            for (o2 = e2; k(o2); ) {
              o2 = k(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            for (o2 = e2; y(o2); ) {
              o2 = y(o2);
              const t3 = this.getPieceOnLocationColor(o2);
              if (this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), t3) break;
            }
            return i2;
          }
          getQueenMoves(t2, e2) {
            return [...this.getRookMoves(t2, e2), ...this.getBishopMoves(t2, e2)];
          }
          getKingMoves(t2, e2) {
            const i2 = [], n2 = this.getPieceColor(t2);
            let o2 = e2;
            return o2 = D(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = e2, o2 = b(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = e2, o2 = A(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = e2, o2 = H(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = e2, o2 = d(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = e2, o2 = v(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = e2, o2 = k(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), o2 = e2, o2 = y(o2), o2 && this.getPieceOnLocationColor(o2) !== n2 && i2.push(o2), i2;
          }
          getPieceColor(t2) {
            return t2.toUpperCase() === t2 ? c : r;
          }
          getPieceOnLocationColor(t2) {
            const e2 = this.getPiece(t2);
            return e2 ? e2.toUpperCase() === e2 ? c : r : null;
          }
          getPiece(t2) {
            return this.configuration.pieces[t2];
          }
          setPiece(t2, e2) {
            if (!function(t3) {
              return Object.values(s).includes(t3);
            }(e2)) throw new Error("Invalid piece " + e2);
            if (!I(t2)) throw new Error("Invalid location " + t2);
            this.configuration.pieces[t2.toUpperCase()] = e2;
          }
          removePiece(t2) {
            if (!I(t2)) throw new Error("Invalid location " + t2);
            delete this.configuration.pieces[t2.toUpperCase()];
          }
          isEmpty(t2) {
            if (!I(t2)) throw new Error("Invalid location " + t2);
            return !this.configuration.pieces[t2.toUpperCase()];
          }
          getEnemyColor(t2) {
            return t2 === c ? r : c;
          }
          getPlayingColor() {
            return this.configuration.turn;
          }
          getNonPlayingColor() {
            return this.isPlayingWhite() ? r : c;
          }
          isPlayingWhite() {
            return this.configuration.turn === c;
          }
          isPlayingBlack() {
            return this.configuration.turn === r;
          }
          addMoveToHistory(t2, e2) {
            this.history.push({ from: t2, to: e2, configuration: JSON.parse(JSON.stringify(this.configuration)) });
          }
          move(t2, e2) {
            const i2 = this.getPiece(t2), n2 = this.getPiece(e2);
            if (!i2) throw new Error("There is no piece at " + t2);
            var o2, s2;
            if (Object.assign(this.configuration.pieces, { [e2]: i2 }), delete this.configuration.pieces[t2], this.isPlayingWhite() && this.isPawn(i2) && "8" === e2[1] && Object.assign(this.configuration.pieces, { [e2]: "Q" }), this.isPlayingBlack() && this.isPawn(i2) && "1" === e2[1] && Object.assign(this.configuration.pieces, { [e2]: "q" }), this.isPawn(i2) && e2 === this.configuration.enPassant && delete this.configuration.pieces[o2 = e2, s2 = this.getPlayingColor(), s2 === c ? f.DOWN[o2] : f.UP[o2]], this.isPawn(i2) && this.isPlayingWhite() && "2" === t2[1] && "4" === e2[1] ? this.configuration.enPassant = t2[0] + "3" : this.isPawn(i2) && this.isPlayingBlack() && "7" === t2[1] && "5" === e2[1] ? this.configuration.enPassant = t2[0] + "6" : this.configuration.enPassant = null, "E1" === t2 && Object.assign(this.configuration.castling, { whiteLong: false, whiteShort: false }), "E8" === t2 && Object.assign(this.configuration.castling, { blackLong: false, blackShort: false }), "A1" === t2 && Object.assign(this.configuration.castling, { whiteLong: false }), "H1" === t2 && Object.assign(this.configuration.castling, { whiteShort: false }), "A8" === t2 && Object.assign(this.configuration.castling, { blackLong: false }), "H8" === t2 && Object.assign(this.configuration.castling, { blackShort: false }), this.isKing(i2)) {
              if ("E1" === t2 && "C1" === e2) return this.move("A1", "D1");
              if ("E8" === t2 && "C8" === e2) return this.move("A8", "D8");
              if ("E1" === t2 && "G1" === e2) return this.move("H1", "F1");
              if ("E8" === t2 && "G8" === e2) return this.move("H8", "F8");
            }
            this.configuration.turn = this.isPlayingWhite() ? r : c, this.isPlayingWhite() && this.configuration.fullMove++, this.configuration.halfMove++, (n2 || this.isPawn(i2)) && (this.configuration.halfMove = 0);
          }
          exportJson() {
            return { moves: this.getMoves(), pieces: this.configuration.pieces, turn: this.configuration.turn, isFinished: this.configuration.isFinished, check: this.hasPlayingPlayerCheck(), checkMate: this.configuration.checkMate, castling: this.configuration.castling, enPassant: this.configuration.enPassant, halfMove: this.configuration.halfMove, fullMove: this.configuration.fullMove };
          }
          calculateAiMove(t2) {
            return this.calculateAiMoves(t2)[0];
          }
          calculateAiMoves(t2) {
            if (t2 = parseInt(t2), !l.includes(t2)) throw new Error(`Invalid level ${t2}. You can choose ${l.join(",")}`);
            this.shouldIncreaseLevel() && t2++;
            const e2 = [], i2 = this.calculateScore(this.getPlayingColor()), n2 = this.getMoves();
            for (const o2 in n2) n2[o2].map((n3) => {
              const s2 = this.getTestBoard(), r2 = Boolean(s2.getPiece(n3));
              s2.move(o2, n3), e2.push({ from: o2, to: n3, score: s2.testMoveScores(this.getPlayingColor(), t2, r2, r2 ? s2.calculateScore(this.getPlayingColor()) : i2, n3).score + s2.calculateScoreByPiecesLocation(this.getPlayingColor()) + Math.floor(Math.random() * (this.configuration.halfMove > 10 ? this.configuration.halfMove - 10 : 1) * 10) / 10 });
            });
            return e2.sort((t3, e3) => t3.score < e3.score ? 1 : t3.score > e3.score ? -1 : 0), e2;
          }
          shouldIncreaseLevel() {
            return this.getIngamePiecesValue() < 50;
          }
          getIngamePiecesValue() {
            let t2 = 0;
            for (const e2 in this.configuration.pieces) {
              t2 += T(this.getPiece(e2));
            }
            return t2;
          }
          getTestBoard() {
            const t2 = { pieces: Object.assign({}, this.configuration.pieces), castling: Object.assign({}, this.configuration.castling), turn: this.configuration.turn, enPassant: this.configuration.enPassant };
            return new q(t2);
          }
          testMoveScores(t2, e2, i2, n2, o2, s2 = 1) {
            let r2 = null;
            if (s2 < u[e2] && this.hasPlayingPlayerCheck() ? r2 = this.getMoves(this.getPlayingColor()) : (s2 < a[e2] || i2 && s2 < u[e2]) && (r2 = this.getMoves(this.getPlayingColor(), 5)), this.configuration.isFinished) return { score: this.calculateScore(t2) + (this.getPlayingColor() === t2 ? s2 : -s2), max: true };
            if (!r2) {
              if (null !== n2) return { score: n2, max: false };
              return { score: this.calculateScore(t2), max: false };
            }
            let c2 = this.getPlayingColor() === t2 ? x : Q, l2 = false;
            for (const i3 in r2) l2 || r2[i3].map((o3) => {
              if (l2) return;
              const r3 = this.getTestBoard(), a2 = Boolean(r3.getPiece(o3));
              if (r3.move(i3, o3), r3.hasNonPlayingPlayerCheck()) return;
              const u2 = r3.testMoveScores(t2, e2, a2, a2 ? r3.calculateScore(t2) : n2, o3, s2 + 1);
              u2.max && (l2 = true), c2 = this.getPlayingColor() === t2 ? Math.max(c2, u2.score) : Math.min(c2, u2.score);
            });
            return { score: c2, max: false };
          }
          calculateScoreByPiecesLocation(t2 = this.getPlayingColor()) {
            const e2 = { A: 0, B: 1, C: 2, D: 3, E: 4, F: 5, G: 6, H: 7 };
            let i2 = 0;
            for (const n2 in this.configuration.pieces) {
              const o2 = this.getPiece(n2);
              if (G[o2]) {
                const s2 = G[o2][n2[1] - 1][e2[n2[0]]];
                i2 += 0.5 * (this.getPieceColor(o2) === t2 ? s2 : -s2);
              }
            }
            return i2;
          }
          calculateScore(t2 = this.getPlayingColor()) {
            let e2 = 0;
            if (this.configuration.checkMate) return this.getPlayingColor() === t2 ? x : Q;
            if (this.configuration.isFinished) return this.getPlayingColor() === t2 ? Q : x;
            for (const i2 in this.configuration.pieces) {
              const n2 = this.getPiece(i2);
              this.getPieceColor(n2) === t2 ? e2 += 10 * T(n2) : e2 -= 10 * T(n2);
            }
            return e2;
          }
        }
        class $ {
          constructor(t2) {
            this.board = new q(t2);
          }
          move(t2, e2) {
            t2 = t2.toUpperCase(), e2 = e2.toUpperCase();
            const i2 = this.board.getMoves();
            if (!i2[t2] || !i2[t2].includes(e2)) throw new Error(`Invalid move from ${t2} to ${e2} for ${this.board.getPlayingColor()}`);
            return this.board.addMoveToHistory(t2, e2), this.board.move(t2, e2), { [t2]: e2 };
          }
          moves(t2 = null) {
            return (t2 ? this.board.getMoves()[t2.toUpperCase()] : this.board.getMoves()) || [];
          }
          setPiece(t2, e2) {
            this.board.setPiece(t2, e2);
          }
          removePiece(t2) {
            this.board.removePiece(t2);
          }
          aiMove(t2 = 2) {
            const e2 = this.board.calculateAiMove(t2);
            return this.move(e2.from, e2.to);
          }
          getHistory(t2 = false) {
            return t2 ? this.board.history.reverse() : this.board.history;
          }
          printToConsole() {
            !function(t2) {
              process.stdout.write("\n");
              let e2 = c;
              Object.assign([], o).reverse().map((i2) => {
                process.stdout.write("" + i2), n.map((n2) => {
                  switch (t2.pieces[`${n2}${i2}`]) {
                    case "K":
                      process.stdout.write("♚");
                      break;
                    case "Q":
                      process.stdout.write("♛");
                      break;
                    case "R":
                      process.stdout.write("♜");
                      break;
                    case "B":
                      process.stdout.write("♝");
                      break;
                    case "N":
                      process.stdout.write("♞");
                      break;
                    case "P":
                      process.stdout.write("♟");
                      break;
                    case "k":
                      process.stdout.write("♔");
                      break;
                    case "q":
                      process.stdout.write("♕");
                      break;
                    case "r":
                      process.stdout.write("♖");
                      break;
                    case "b":
                      process.stdout.write("♗");
                      break;
                    case "n":
                      process.stdout.write("♘");
                      break;
                    case "p":
                      process.stdout.write("♙");
                      break;
                    default:
                      process.stdout.write(e2 === c ? "█" : "░");
                  }
                  e2 = e2 === c ? r : c;
                }), e2 = e2 === c ? r : c, process.stdout.write("\n");
              }), process.stdout.write(" "), n.map((t3) => {
                process.stdout.write("" + t3);
              }), process.stdout.write("\n");
            }(this.board.configuration);
          }
          exportJson() {
            return this.board.exportJson();
          }
          exportFEN() {
            return function(t2) {
              let e2 = "";
              Object.assign([], o).reverse().map((i3) => {
                let o2 = 0;
                i3 < 8 && (e2 += "/"), n.map((n2) => {
                  const s3 = t2.pieces[`${n2}${i3}`];
                  s3 ? (o2 && (e2 += o2.toString(), o2 = 0), e2 += s3) : o2++;
                }), e2 += "" + (o2 || "");
              }), e2 += t2.turn === c ? " w " : " b ";
              const { whiteShort: i2, whiteLong: s2, blackLong: r2, blackShort: l2 } = t2.castling;
              return s2 || i2 || r2 || l2 ? (i2 && (e2 += "K"), s2 && (e2 += "Q"), l2 && (e2 += "k"), r2 && (e2 += "q")) : e2 += "-", e2 += " " + (t2.enPassant ? t2.enPassant.toLowerCase() : "-"), e2 += " " + t2.halfMove, e2 += " " + t2.fullMove, e2;
            }(this.board.configuration);
          }
        }
        function J(t2) {
          if (!t2) throw new Error("Configuration param required.");
          return new $(t2).moves();
        }
        function V(t2) {
          if (!t2) throw new Error("Configuration param required.");
          return new $(t2).exportJson();
        }
        function Y(t2) {
          if (!t2) throw new Error("Configuration param required.");
          return new $(t2).exportFEN();
        }
        function z(t2, e2, i2) {
          if (!t2) throw new Error("Configuration param required.");
          const n2 = new $(t2);
          return n2.move(e2, i2), "object" == typeof t2 ? n2.exportJson() : n2.exportFEN();
        }
        function X(t2, e2 = 2) {
          if (!t2) throw new Error("Configuration param required.");
          const i2 = new $(t2).board.calculateAiMove(e2);
          return { [i2.from]: i2.to };
        }
      }]);
    });
  }
});
export default require_js_chess_engine();
//# sourceMappingURL=js-chess-engine.js.map
